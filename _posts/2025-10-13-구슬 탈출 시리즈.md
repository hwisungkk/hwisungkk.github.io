---
title: 구슬 탈출 시리즈
date: 2025-10-13 19:12:11 +09:00
last_modified_at: 2025-10-13 23:10:05 +09:00
categories: [algorithm, boj]
tags:
  [
    '구슬 탈출',
    '백준',
    '그래프 탐색'
  ]
---
# **구슬 탈출 시리즈**

[구슬 탈출 시리즈](https://www.acmicpc.net/workbook/view/6524)

2048문제와 같이 백준 빡구현 문제 중 하나로 계속 들어왔던 문제라 한번 쭉 풀어봤다.<br>
골드 1치고는 아이디어도 간단하고 구현을 하는 것에도 그렇게 어렵지 않았던 것 같다.<br>

1번의 변형으로 2, 3, 4를 쉽게 풀 수 있으므로 1번만 신경써주면 됐다.<br>

우선 구현하기 편했던 것으로 테두리가 벽으로 둘려 쌓여있는 조건이 있었다.<br>
이미 왔던 경로를 다시하지 않도록 체크는 map(파랑 x, 파랑 y, 빨강 x, 빨강 y)로 구현했다.<br>
4가지가 모두 같아야지 이미 지나온 경로라고 할 수 있기 때문이다.<br>

다음 상하좌우로 움직이는 것은 하나만 구현하면 나머지는 복붙으로 조금씩 바꾸면 가능하다.<br>
주의해야 하는 것은 빨강과 파랑이 같은 줄에 있을 때 판을 기울이면 순서가 지켜져야 한다는 것.<br>

그래서 이동하는 방향으로 벽에 부딪힐 때까지 공들을 전부 옮기고 그 때 파란 공과 빨간 공이 겹치면<br>
이동하는 방향 벽에 더 멀었던 공을 반대쪽으로 1만큼 옮겨주는 방법을 사용했다.

```
int main()
{
    ios_base ::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    long long mod =  1'000'000'007;
    using P=pair<ll,ll>;
    using PP = pair<P,P>;

    long long a, b, c, d;
    long long ans = 1e9;

    cin >> n >> m;
    vector<string> board(n);
    for(int i=0;i<n;i++) cin>>board[i];

    P red; //뺄거
    P blue; // 들어가면 안됨
    P holl;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(board[i][j]=='B')blue={i,j};
            else if(board[i][j]=='R')red={i,j};
            if(board[i][j]=='O')holl={i,j};
        }
    }
    //dx dy 오른쪽, 왼쪽, 위쪽, 아래쪽임
    map<PP, int> mp;
    int hx=holl.first;
    int hy=holl.second;

    bool pause=0;
    int an=1e6;

    function<void(int, int, int, int ,int ,int)>
    dfs=[&](int cnt, int dir, int bx, int by, int rx, int ry){
        pause=0;
        flag=0;
        if(mp[{{bx, by}, {rx, ry}}]==0 || mp[{{bx, by}, {rx, ry}}]>cnt){
            mp[{{bx, by}, {rx, ry}}]=cnt;
        }
        else return;

        if(cnt==11){
            return;
        }
        for(int x=0;x<4;x++){
            pause=0;
            flag=0;
            int pbx=bx;
            int pby=by;
            int prx=rx;
            int pry=ry;
            if(x==dir)continue;
            
            if(x==0){ //오른쪽
                if(pby>pry){
                    while(board[pbx][pby]!='#'){
                        if(pbx==hx && pby==hy){
                            pause=1;//구멍에 들어감
                            break;;
                        }
                        pby++;
                    }
                    pby-=1;
                    if(pause)continue;
                    else{
                        while(board[prx][pry]!='#'){
                            if(prx==hx && pry==hy){
                                flag=1;//구멍에 들어감
                                break;
                            }
                            pry++;
                        }
                        pry-=1;
                        if(pbx==prx && pby==pry)pry-=1;
                    }
                    if(!pause && flag){
                        an=min(an, cnt);
                        continue;
                    }
                }
                else{
                    while(board[pbx][pby]!='#'){
                        if(pbx==hx && pby==hy){
                            pause=1;//구멍에 들어감
                            break;
                        }
                        pby++;
                    }
                    pby-=1;
                    if(pause)continue;
                    else{
                        while(board[prx][pry]!='#'){
                            if(prx==hx && pry==hy){
                                flag=1;//구멍에 들어감
                                break;
                            }
                            pry++;
                        }
                        pry-=1;
                        if(pbx==prx && pby==pry)pby-=1;
                    }
                    if(!pause && flag){
                        an=min(an, cnt);
                        continue;
                    }
                }
            }
            else if(x==1){ //왼쪽
                if(pby<pry){
                    while(board[pbx][pby]!='#'){
                        if(pbx==hx && pby==hy){
                            pause=1;//구멍에 들어감
                            break;
                        }
                        pby--;
                    }
                    pby+=1;
                    if(pause)continue;
                    else{
                        while(board[prx][pry]!='#'){
                            if(prx==hx && pry==hy){
                                flag=1;//구멍에 들어감
                                break;
                            }
                            pry--;
                        }
                        pry+=1;
                        if(pbx==prx && pby==pry)pry+=1;
                    }
                    if(!pause && flag){
                        an=min(an, cnt);
                        continue;
                    }
                }
                else{
                    while(board[pbx][pby]!='#'){
                        if(pbx==hx && pby==hy){
                            pause=1;//구멍에 들어감
                            break;
                        }
                        pby--;
                    }
                    pby+=1;
                    if(pause)continue;
                    else{
                        while(board[prx][pry]!='#'){
                            if(prx==hx && pry==hy){
                                flag=1;//구멍에 들어감
                                break;
                            }
                            pry--;
                        }
                        pry+=1;
                        if(pbx==prx && pby==pry)pby+=1;
                    }
                    if(!pause && flag){
                        an=min(an, cnt);
                        continue;
                    }
                }
            }
            else if(x==2){ //위쪽
                if(pbx<prx){
                    while(board[pbx][pby]!='#'){
                        if(pbx==hx && pby==hy){
                            pause=1;//구멍에 들어감
                            break;
                        }
                        pbx--;
                    }
                    pbx+=1;
                    if(pause)continue;
                    else{
                        while(board[prx][pry]!='#'){
                            if(prx==hx && pry==hy){
                                flag=1;//구멍에 들어감
                                break;
                            }
                            prx--;
                        }
                        prx+=1;
                        if(pbx==prx && pby==pry)prx+=1;
                    }
                    if(!pause && flag){
                        an=min(an, cnt);
                        continue;
                    }
                }
                else{
                    while(board[pbx][pby]!='#'){
                        if(pbx==hx && pby==hy){
                            pause=1;//구멍에 들어감
                            break;
                        }
                        pbx--;
                    }
                    pbx+=1;
                    if(pause)continue;
                    else{
                        while(board[prx][pry]!='#'){
                            if(prx==hx && pry==hy){
                                flag=1;//구멍에 들어감
                                break;
                            }
                            prx--;
                        }
                        prx+=1;
                        if(pbx==prx && pby==pry)pbx+=1;
                    }
                    if(!pause && flag){
                        an=min(an, cnt);
                        continue;
                    }
                }
            }
            else if(x==3){ //아래쪽
                if(pbx>prx){
                    while(board[pbx][pby]!='#'){
                        if(pbx==hx && pby==hy){
                            pause=1;//구멍에 들어감
                            break;
                        }
                        pbx++;
                    }
                    pbx-=1;
                    if(pause)continue;
                    else{
                        while(board[prx][pry]!='#'){
                            if(prx==hx && pry==hy){
                                flag=1;//구멍에 들어감
                                break;
                            }
                            prx++;
                        }
                        prx-=1;
                        if(pbx==prx && pby==pry)prx-=1;
                    }
                    if(!pause && flag){
                        an=min(an, cnt);
                        continue;
                    }
                }
                else{
                    while(board[pbx][pby]!='#'){
                        if(pbx==hx && pby==hy){
                            pause=1;//구멍에 들어감
                            break;
                        }
                        pbx++;
                    }
                    pbx-=1;
                    if(pause)continue;
                    else{
                        while(board[prx][pry]!='#'){
                            if(prx==hx && pry==hy){
                                flag=1;//구멍에 들어감
                                break;
                            }
                            prx++;
                        }
                        prx-=1;
                        if(pbx==prx && pby==pry)pbx-=1;
                    }
                    if(!pause && flag){
                        an=min(an, cnt);
                        continue;
                    }
                }
            }
            dfs(cnt+1, x, pbx, pby, prx, pry);
        }
    };

    dfs(1, -1, blue.first, blue.second, red.first, red.second);

    //cout << an << '\n';
    if(an<=10)cout<<1;
    else cout<<0;
    
    return 0;
}
```

전체 코드가 길지만 같은 내용의 중복이다.<br>
2번은 횟수를 출력하면 되므로 an을 출력하면 되고<br>
4번은 max 10의 조건이 사라진 것이니 DFS에서 그 조건을 없애주면 된다.<br>
3번은 자주 쓰는 방법으로 경로 인자를 DFS 함수에 추가해서 해결했다.