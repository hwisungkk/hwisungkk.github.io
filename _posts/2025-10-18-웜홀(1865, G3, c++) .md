---
title: 웜홀(1865, G3, c++)
date: 2025-10-18 15:34:32 +09:00
render_with_liquid: false
last_modified_at: 2025-10-18 16:22:12 +09:00
categories: [algorithm, boj]
tags:
  [
    '그래프 이론',
    '벨만-포드',
    '백준',                  
    '1865'
  ]
---
# **웜홀**

[웜홀](https://www.acmicpc.net/problem/1865)

### 문제 
때는 2020년, 백준이는 월드나라의 한 국민이다.<br>
월드나라에는 N개의 지점이 있고 N개의 지점 사이에는 M개의 도로와 W개의 웜홀이 있다.<br>
(단 도로는 방향이 없으며 웜홀은 방향이 있다.)<br>

웜홀은 시작 위치에서 도착 위치로 가는 하나의 경로인데,<br>
특이하게도 도착을 하게 되면 시작을 하였을 때보다 시간이 뒤로 가게 된다.<br>
웜홀 내에서는 시계가 거꾸로 간다고 생각하여도 좋다.

시간 여행을 매우 좋아하는 백준이는 한 가지 궁금증에 빠졌다.<br>
한 지점에서 출발을 하여서 시간여행을 하기 시작하여 다시 출발을 하였던 위치로 돌아왔을 때,<br>
출발을 하였을 때보다 시간이 되돌아가 있는 경우가 있는지 없는지 궁금해졌다.

여러분은 백준이를 도와 이런 일이 가능한지 불가능한지 구하는 프로그램을 작성하여라.

### 입력
첫 번째 줄에는 테스트케이스의 개수 TC(1 ≤ TC ≤ 5)가 주어진다.<br>

그리고 두 번째 줄부터 TC개의 테스트케이스가 차례로 주어지는데<br>
각 테스트케이스의 첫 번째 줄에는 지점의 수 N(1 ≤ N ≤ 500),<br>
도로의 개수 M(1 ≤ M ≤ 2500), 웜홀의 개수 W(1 ≤ W ≤ 200)이 주어진다.<br>

그리고 두 번째 줄부터 M+1번째 줄에 도로의 정보가 주어지는데 각 도로의 정보는 S, E, T 세 정수로 주어진다.<br>
S와 E는 연결된 지점의 번호, T는 이 도로를 통해 이동하는데 걸리는 시간을 의미한다.<br>

그리고 M+2번째 줄부터 M+W+1번째 줄까지 웜홀의 정보가 S, E, T 세 정수로 주어지는데 S는 시작 지점,<br>
E는 도착 지점, T는 줄어드는 시간을 의미한다. T는 10,000보다 작거나 같은 자연수 또는 0이다.

두 지점을 연결하는 도로가 한 개보다 많을 수도 있다. 지점의 번호는 1부터 N까지 자연수로 중복 없이 매겨져 있다.

### 출력
TC개의 줄에 걸쳐서 만약에 시간이 줄어들면서 출발 위치로 돌아오는 것이 가능하면 YES, 불가능하면 NO를 출력한다.

### 풀이
우선 문제를 이해하는 것에 시간이 걸렸는데 정리를 하면 아무 하나의 점에서 시작해도 되는 것이고<br>
돌아왔을 때 출발 시점보다 이전의 시간에 들어왔다면 YES, 아니면 NO를 출력하는 것이다.

우선 음의 가중치가 있기에 벨만-포드를 써야겠다고 생각했고<br>
어떤 점에서라도 출발 위치로 시간이 줄어들며 돌아가는 경우가 있는지 확인하는 문제이므로<br>
간단하게 음의 값으로 돌아오는 사이클이 있는지 확인을 하면 된다고 생각했다.<br>

그런데 항상 쓰는 방법으로 구현했더니 WA가 되서 이유를 찾다보니 
https://www.acmicpc.net/board/view/72995

좋은 글이 하나 있었다.<br>

```c++
dist[1]=0;
        for(int i=0;i<n+1;i++){
            for(int j=0;j<edge.size();j++){
                int from = edge[j].first.first;
                int to = edge[j].first.second;
                int val = edge[j].second;

                if(dist[from]!=1e9){
                    if(dist[to]>dist[from]+val){
                        if(i==n)flag=1;
                        dist[to]=dist[from]+val;
                    }
                }
            }
        }
```

처음 한 방법은 dist 배열을 1e9로 설정한 후 1을 시작 지점으로 잡고 했는데<br>
주어진 그래프가 연결 그래프라는 보장이 없기 때문에 사이클을 전부 구할 수 없었다.<br>

그래서 두 가지 방법으로 이것을 해결하는 방법이 있는데 우선 어떤 지점에서도 시작해도 되기에<br>
1e9로 방문하지 않은 정점을 체크하지 않아도 된다는 것이다.<br>
문제가 음의 사이클이 존재하는지 안하는지만을 구하면 되기 때문에 해당 방법으로 찾을 수 있었다.<br>

이렇게 dist 배열을 0으로 만든 후 방문하지 못하는 정점은 없기 때문에<br>
값이 작아질 때만 확인하고 n번째 반복과정에서도 값이 업데이트 되면 음의 사이클이 존재한다.<br>
```c++
int main()
{
    ios_base ::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    long long mod =  998'244'353;
    using P=pair<ll,ll>;
    using PP = pair<P,P>;

    long long a, b, c, d;
    long long ans = 1e9;

    int tc;
    cin >> tc;

    while(tc-->0){
        flag=0;
        vector<pair<P, ll>> edge;
        cin >> n >> m >> t;
        vector<int> dist(n+1, 0);
        for(int i=0;i<m;i++){ //얜 경로
            cin >> a >> b >> c;
            edge.push_back({{a, b}, c});
            edge.push_back({{b, a}, c});
        }
        for(int i=0;i<t;i++){ //얜 웜홀
            cin >> a >> b >> c;
            edge.push_back({{a, b}, -1*c});
        }

        for(int i=0;i<n+1;i++){
            for(int j=0;j<edge.size();j++){
                int from = edge[j].first.first;
                int to = edge[j].first.second;
                int val = edge[j].second;

                //if(dist[from]!=1e9){
                    if(dist[to]>dist[from]+val){
                        if(i==n)flag=1;
                        dist[to]=dist[from]+val;
                    }
                //}
            }
        }
        if(flag)cout<<"YES"<<'\n';
        else cout <<"NO"<<'\n';
    }
    
    return 0;
}
```

아니면 시작 지점을 두고 찾는 방법도 있었는데 임의의 점 n+1을 놓는 것이다.<br>
이 정점과 모든 정점간에 가중치가 0인 간선을 그리고 n+1부터 시작하면 해결이 된다.<br>

모든 정점에 도달이 가능한 환경이 되고, 0으로 초기화 되기에 사실상 위와 같은 느낌으로 작동한다.<br>
```c++
int main()
{
    ios_base ::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    long long mod =  998'244'353;
    using P=pair<ll,ll>;
    using PP = pair<P,P>;

    long long a, b, c, d;
    long long ans = 1e9;

    int tc;
    cin >> tc;

    while(tc-->0){
        flag=0;
        vector<pair<P, ll>> edge;
        cin >> n >> m >> t;
        vector<int> dist(n+2, 1e9);
        for(int i=0;i<m;i++){ //얜 경로
            cin >> a >> b >> c;
            edge.push_back({{a, b}, c});
            edge.push_back({{b, a}, c});
        }
        for(int i=0;i<t;i++){ //얜 웜홀
            cin >> a >> b >> c;
            edge.push_back({{a, b}, -1*c});
        }
        for(int i=1;i<=n;i++)edge.push_back({{n+1, i}, 0});

        dist[1]=0;
        for(int i=0;i<n+2;i++){
            for(int j=0;j<edge.size();j++){
                int from = edge[j].first.first;
                int to = edge[j].first.second;
                int val = edge[j].second;

                dist[n+1]=0;
                if(dist[from]!=1e9){
                    if(dist[to]>dist[from]+val){
                        if(i==n)flag=1;
                        dist[to]=dist[from]+val;
                    }
                }
            }
        }
        if(flag)cout<<"YES"<<'\n';
        else cout <<"NO"<<'\n';
    }
    
    return 0;
}
```

벨만-포드 알고리즘 문제는 별로 안 풀어봤는데 기본 예제 문제임에도 생각해 볼 것이 있는 문제였다.<br>