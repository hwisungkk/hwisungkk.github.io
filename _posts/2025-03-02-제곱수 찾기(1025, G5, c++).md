---
title: 제곱수 찾기(1025, G5, c++)
date: 2025-03-02 23:50:11 +09:00
last_modified_at: 2025-03-03 00:12:03 +09:00
categories: [algorithm, boj]
tags:
  [
    '브루트포스',
    '백준',
    '1025'
  ]
---
# **제곱수 찾기**

[제곱수 찾기](https://www.acmicpc.net/problem/1025)

### 문제
N행 M열의 표 A가 있고, 표의 각 칸에는 숫자가 하나씩 적혀있다.

연두는 서로 다른 1개 이상의 칸을 선택하려고 하는데, 행의 번호가 선택한 순서대로 등차수열을 이루고 있어야 하고,<br>
열의 번호도 선택한 순서대로 등차수열을 이루고 있어야 한다.<br>
이렇게 선택한 칸에 적힌 수를 순서대로 이어붙이면 정수를 하나 만들 수 있다.

연두가 만들 수 있는 정수 중에서 가장 큰 완전 제곱수를 구해보자. 완전 제곱수란 어떤 정수를 제곱한 수이다.

### 입력
첫째 줄에 N, M이 주어진다. 둘째 줄부터 N개의 줄에는 표에 적힌 숫자가 1번 행부터 N번 행까지 순서대로 한 줄에 한 행씩 주어진다.<br>
한 행에 적힌 숫자는 1번 열부터 M번 열까지 순서대로 주어지고, 공백없이 모두 붙여져 있다.

### 출력
첫째 줄에 연두가 만들 수 있는 가장 큰 완전 제곱수를 출력한다. 만약, 완전 제곱수를 만들 수 없는 경우에는 -1을 출력한다.

### 제한
1 ≤ N, M ≤ 9
표에 적힌 숫자는 0보다 크거나 같고, 9보다 작거나 같다.
```
예제 입력 1 
2 3
123
456

예제 출력 1 
64

만들 수 있는 세자리 수는 123, 321, 456, 654이다. 이 중 완전 제곱수는 없기 때문에 정답은 64가 된다.

예제 입력 2 
5 5
00000
00000
00200
00000
00000

예제 출력 2 
0

0은 완전 제곱수이고, 입력으로 주어진 표에서 만들 수 있는 가장 큰 완전 제곱수이다.

예제 입력 3 
6 7
3791178
1283252
4103617
8233494
8725572
2937261

예제 출력 3 
320356

모든 i번 행의 i번 열에 적힌 수를 이어붙이면 320356을 만들 수 있고, 이 수는 5662 = 320356 이다.

예제 입력 4 
5 9
135791357
357913579
579135791
791357913
913579135

예제 출력 4 
9

홀수 숫자 두 개로 끝나는 완전 제곱수는 없다. 따라서, 만들 수 있는 가장 큰 완전 제곱수는 9이다.

예제 입력 5 
9 9
553333733
775337775
777537775
777357333
755553557
355533335
373773573
337373777
775557777

예제 출력 5 
-1

3, 5, 7만을 이용해 완전 제곱수를 만들 수 없다.

예제 입력 6 
9 9
257240281
197510846
014345401
035562575
974935632
865865933
684684987
768934659
287493867

예제 출력 6 
95481
```
### 풀이
반복문이 몇 번이나 중첩되는 완전탐색 문제이다.<br>
시작 위치를 i, j를 통해 잡아주고, 8방향으로 확인해야 하기 때문에 dx, dy를 만든다.<br>

그 후 방향을 선택하는 k와 x방향, y방향으로 얼만큼 이동할지를 변수로 만들어 준다.<br>
그렇게 5개의 반복문으로 완전 탐색을 하면 문제를 풀 수 있다.


```c++
#include <iostream>
#include <vector>
#include <string>
#include <queue>
#include <stack>
#include <set>
#include <functional>
#include <algorithm>
#include <math.h>
#include <map>
using namespace std;
bool ch_sq(int n){
    int che = int(sqrt(n));
    if (che * che == n)return 1;
    else return 0;
}
int main()
{
    ios_base ::sync_with_stdio(false); 
    cin.tie(NULL);
    cout.tie(NULL);
    
    int a, b, c, d;
    int n, m, k, t;
    int o_1, o_2;

    cin >> n >> m;
    string s;
    vector<vector<int>> v(n, vector<int>(m));
    int mx = -1;
    for(int i=0;i<n;i++){
        cin >> s;
        for(int j=0;j<m;j++){
            v[i][j] = int(s[j]-48);
        }
    }
    int dx[8] = {0,0,-1,1,-1,1,-1,1}; //오른쪽, 왼쪽, 위, 밑, 왼대위, 왼대아래, 오대위, 오대아래
    int dy[8] = {1,-1,0,0,-1,1,1,-1};
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            int s_i = i, s_j = j;
            for(int k=0;k<8;k++){
                for(int x=1;x<=8;x++){
                    for(int y=1;y<=8;y++){
                    int num = v[i][j];
                    if(ch_sq(num)) mx = max(mx, num);
                        while(i+(dx[k]*x) >= 0 && i+(dx[k]*x) < n && j+(dy[k]*y) >= 0 && j+(dy[k]*y) < m){
                            i+=(dx[k]*x);
                            j+=(dy[k]*y);
                            num*=10;
                            num+=v[i][j];
                            if(ch_sq(num)) mx = max(mx, num);
                        }
                        i = s_i, j = s_j;
                    }
                }
            }
        }
    }
    cout << mx;

    return 0;
}
```
