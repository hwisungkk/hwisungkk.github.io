---
title: C언어 (11) 포인터와 배열2
date: 2024-12-26 21:06:44 +09:00
last_modified_at: 2024-12-27 14:31:48 +09:00
categories: [language, C Language]
tags:
  [
    'C언어',
    'C Language',
    'C언어 기초'
  ]
---
# **C언어 (11) 포인터와 배열2**
> 포인터에 대해 간단히 보았는데, 활용에 대해서는 아직 잘 모르겠다.<br>
> 포인터의 특성을 좀 더 보고, 배열과 연관지어 보며 어떻게 사용하는지 알아보자.<br>

### 다중 포인터
```c
int** ppnum;
```
이런 포인터는 존재할 수 있을까?<br>
포인터 변수도 주소를 가지고, 8바이트 또는 4바이트의 크기를 가진 변수이다.<br>
그렇다면 포인터 변수의 주소를 저장하는 포인터 변수도 만들 수 있지 않을까?<br>
```c
#include<stdio.h>
int main() {
	int num = 10;
	int* p1 = &num;
	int** p2 = &p1;
	int*** p3 = &p2;

	printf("%p %p %p\n", p1, p2, p3);
	printf("%d %d %d %d", num, *p1, **p2, ***p3);

	return 0;
}
```
![image](/assets/img/C_lang/10_1.PNG) <br>
코드로 보면 p1은 num의 주소를 가진다. p2는 p1의 주소를 가진다. p3는 p2의 주소를 가진다.<br>
결과를 보면 \*p2는 num의 주소를 가지고, \*\*p2는 num의 값을 가진다.<br>
즉 \*\*\*p3 == \*\*p2 == \*p1 = num이다.

![image](/assets/img/C_lang/10_2.PNG) <br>
이런 짤도 있는데 p2에서 int형 변수 num에 접근하려면 2번 참조해야 할 것이다.<br>
그러면 참조 연산자인 \*을 2번 써주면 된다.
```c
int* p1 = &num;
int* pp1 = &p1;
```
물론 이렇게 그냥 포인터 변수에도 다른 포인터 변수의 주소를 저장할 수 있다.<br>
당연한 이야기지만 이러면 pp1을 통해서 num의 값을 간접 참조하는 것을 불가능하다.<br>
\*pp1으로 참조하는 값은 &num이기 때문이다.<br>

### 포인터의 연산
포인터 변수는 주소값이 들어있는 변수이다. 여기에 더하기와 빼기도 가능할까?<br>
가능하지만 일반적인 변수에 대한 연산과는 조금 다르게 증가하고 감소한다.<br>
char형 주소에 +1을 하면 1 증가, int형 주소에 +1하면 4 증가, double형 주소에 +1하면 8이 증가한다.<br>
```c
#include<stdio.h>
int main() {
	char c;
	int a;
	double d;
	char* pc = &c;
	int* pa = &a;
	double* pd = &d;
	printf("%p %p %p\n", pc, pc+1, pc-1);
	printf("%p %p %p\n", pa, pa+1, pa-1);
	printf("%p %p %p\n", pd, pd+1, pd-1);
	return 0;
}
```
```text
00000007202FFDF0 00000007202FFDF1 00000007202FFDEF
00000007202FFDF4 00000007202FFDF8 00000007202FFDF0
00000007202FFDF8 00000007202FFE00 00000007202FFDF0
```
이렇게 포인터가 가리키는 변수의 크기에 따라 증가하고 감소한다.<br>
이중포인터로 예제를 하나 더 봐보자.<br>
```c
#include<stdio.h>
int main() {
	int a=10;
	int* pa = &a;
	int** ppa = &pa;
	printf("%p %p %p\n", pa, pa + 1, pa + 2);
	printf("%p %p %p\n", ppa, ppa + 1, ppa + 2);
	return 0;
}
```
```text
0000006A688FFBE8 0000006A688FFBEC 0000006A688FFBF0
0000006A688FFBE0 0000006A688FFBE8 0000006A688FFBF0
```
pa가 가리키는 변수는 int이므로 4씩 증가한다.<br>
ppa가 가리키는 변수는 int\*이므로 8씩 증가한다.<br>

그러면 포인터 변수에 곱셈이나 나눗셈이 가능할까? 포인터끼리 더하거나 곱하는 것도 가능할까?<br>
```c
#include<stdio.h>
int main() {
	int a=10;
	int b;
	int* pa = &a;
	int* pb = &b;
	printf("%p %p %p %p %p\n", pa, pa * 2, pa / 2, pa + pb, pa*pb, pa-pb);
	return 0;
}
```
위의 코드를 실행하고 하려면 곱하기, 나누기가 안된다는 것을 알 수 있다.<br>
왜 이것을 지원하지 않을까? 생각하면 주소의 값\*2를 한다는 것에 무슨 의미가 있을까?<br>
주소라는 것은 컴퓨터가 임의로 할당하는 것이므로 주소의 값\*2 라는 연산은 아무런 의미가 없다.<br>
만약 주소의 값\*2한 곳에 무슨 값이 있다고 하더라도 그 값과 원래 주소의 값과는 아무런 연관이 없다.<br>

같은 이유로 나누기도 안되고 포인터간의 더하기, 곱하기도 불가능하다.<br>
포인터 값 2개를 더해서 나온 결과는 값 2개와는 아무런 연관이 없기 때문이다.<br>
그런데 예외적으로 포인터간의 빼기는 지원하고 결과도 잘 나온다.<br>
그 이유를 바로 밑에서 알아보자.

### 포인터와 배열
위의 내용들이 포인터와 배열과의 연관을 설명하기 위해서 한 이야기들이다.<br>
이전에 했던 배열 설명을 보면 이렇게 말을 했다.<br>
```
배열이란 같은 자료형을 가진 연속된 메모리 공간으로 이루어진 자료구조이다
```

![image](/assets/img/C_lang/8_2.PNG)

배열의 원소의 주소는 각각의 자료형의 크기만큼 차이가 난다.<br>
char형 배열에서는 1, int형 배열에서는 4. 이렇게 원소 주소마다 차이가 있다.<br>
그런데 포인터의 덧셈과 뺄셈에서도 딱 이렇게 값이 변화한다.<br>
int형 포인터에 +1을 하면 4가 증가하고, char형 포인터에 +1을 하면 1이 증가한다.<br>
```c
#include<stdio.h>
int main() {
	int arr[3] = { 10, 20, 30 };
	int* pa = &arr[0];
	printf("%p %p %p\n", &arr[0], &arr[1], &arr[2]);
	printf("%p %p %p\n", pa, pa+1, pa+2);
	printf("\n");
	printf("%d %d %d\n", arr[0], arr[1], arr[2]);
	printf("%d %d %d\n", *pa, *(pa + 1), *(pa + 2));
	return 0;
}
```
```text
0000009478B6FDB0 0000009478B6FDB4 0000009478B6FDB8
0000009478B6FDB0 0000009478B6FDB4 0000009478B6FDB8

10 20 30
10 20 30
```
결과는 이렇다. 포인터 변수와 연산을 통해 배열의 원소에 접근할 수 있다는 것이다.<br>

### 배열의 시작 주소
배열의 이름은 배열의 시작 주소와 같다.<br>
```c
#include<stdio.h>
int main() {
	int arr[3] = { 1, 1, 1 };
	int* pa = arr;
	printf("%p %p %p %p %p\n", &arr, &arr[0], arr, arr+0, pa);
	return 0;
}
```
이 코드를 실행해보면 5개의 값은 전부 같다. &arr과 arr도 같고, arr과 &arr[0]도 같다.<br>
arr이라는 배열의 이름은 배열의 시작 주소인 &arr[0]과 같은 값을 가진다는 것이다.<br>
그러면 arr+1은 어떻게 될까? &arr+1이 되고


---
변수의 주소를 저장하는 포인터 변수에 대해서 처음 알아보았다.<br>
아직까지 어려운 것은 크게 없는 것 같은데, 이걸 왜 쓰는거지 싶을 것이다.<br>
어차피 num과 \*pnum이 같다면 그냥 num만 쓰면 되는 것이 아닐까?라고 생각할 수 있다.<br>
다음 글에서 포인터와 배열의 관계를 보며 사용하는 것을 더 자세히 알아보자.