---
title: (웹해킹) 1-4. 네트워크와 프로토콜 (3)
date: 2025-12-29 00:03:42 +09:00
last_modified_at: 2025-12-29 03:21:14 +09:00
categories: [security, web]
tags:
  [
  ]
---

다음은 3계층이다.<br>

![image](/assets/img/security/web/osi7layer_1.PNG)

## 3계층 (네트워크 계층)

2계층이 같은 LAN 안에서의 통신을 담당한다면, 3계층은 서로 다른 네트워크 간의 통신을 담당한다.<br>
스위치로 연결된 컴퓨터들의 집합을 1개의 네트워크라고 하면 라우터라는 장비를 통해 다른 네트워크와 통신이 이뤄진다.<br>

집에 있는 컴퓨터에서 멀리 떨어진 서버에 접속할 때, 중간에 수많은 라우터를 거쳐야 한다.<br>
이런 경로 설정과 주소 지정을 하는 것이 네트워크 계층이다.

2계층의 기능만으로는 큰 네트워크를 구성할 수 없는 것일까? 하면 문제가 있다.<br>
대표적으로는 브로드캐스트의 처리 문제로 브로드캐스팅을 하면 하나의 네트워크 안에 있는 모든 컴퓨터에 전송된다.<br>
컴퓨터가 많아질수록 트래픽에서 문제가 발생하게 된다. <br>

라우터는 이런 브로드캐스트를 중계하지 않기에 네트워크를 나누는 기기가 될 수 있다.<br>

### 인터넷 프로토콜 IP (Internet Protocol)
이런 네트워크간의 데이터 송수신을 인터넷이라고 한다.<br>
떨어진 장소에 있는 컴퓨터끼리 데이터 통신을 하고, 그렇기 위해서는 주소가 필요하다.<br>

MAC 주소는 벤더 코드와 제조 업체가 붙인 번호로만 이루어져있기에 '어디에'라는 정보가 없다.<br>
그래서 IP(Internet Protocol) 주소가 필요하고 네트워크 계층에서 사용하는 논리 주소다.

**논리 주소와 물리 주소**<br>

MAC 주소는 AA:BB:CC:DD:EE:FF의 형식으로 위치 정보는 전혀 들어있지 않고 이를 물리 주소라 하며 바뀔 수 없다.<br>
IP주소는 어느 네트워크의 어느 컴퓨터라는 의미가 담긴 논리 주소이기에 찾아낼 수 있으며 상황에 따라 바뀔 수 있다.<br>

### IP 주소
IP 주소는 현재 2가지 버전이 있으며 IPv4와 IPv6이다.<br>

**IPv4**

32비트 주소 체계로, `192.168.0.1`처럼 점으로 구분된 4개의 10진수로 표현한다.<br>
각 부분은 0~255의 값을 가지므로 8bit\*4 = 32bit이다.<br>
32비트로는 약 2^32=43억 개의 주소를 만들 수 있으므로 인터넷의 보급에 따라 주소의 개수가 부족해졌다.<br>

**IPv6**

128비트 주소 체계로, `2001:0db8:85a3:0000:0000:8a2e:0370:7334` 같은 16진수로 표현하며 콜론으로 구분했다.<br>
16진수로 표현하며 콜론으로 구분한다. 2^128개의 주소를 만들 수 있으므로 사실상 무한대다.<br>

하지만 여전히 우리는 IPv4 체계에 익숙하고, 실제로도 많이 사용한다.<br>
그 이유는 이후에 설명한 NAT의 등장과 기존 인프라와의 호환성이 있다.<br>

우선 **NAT**란 사설 IP를 공인 IP로 변환하는 기술로 단일 IP주소로 수천대의 기기가 연결이 가능해졌다.<br>
또, IPv4와 IPv6는 호환되지 않아 완전한 전환이 이루어져야 하는데 앞선 NAT로 IP 부족 문제가 어느정도 해소되며<br>
전환되는 속도에 있어서 느려진 것 같아 보인다.<br>

### 공인 IP vs 사설 IP
버그바운티나 모의 해킹 대회 신청을 할 때 공인 IP를 제출하라는 말을 들어본적이 있다.<br>

**공인 IP**는 인터넷에서 유일하게 식별 가능한 주소다.<br>
ISP(통신사)에서 할당받으며, 전 세계에서 중복되지 않고, 인터넷에 직접 연결된 서버나 라우터가 가지는 주소다.<br>

**사설 IP**는 LAN 내부에서만 사용하는 주소다.<br>
외부 인터넷에서는 직접 접근할 수 없으며, 사용할 수 있는 범위도 정해져 있다.<br>
```
10.0.0.0        ~ 10.255.255.255     (A 클래스)
172.16.0.0      ~ 172.31.255.255     (B 클래스)
192.168.0.0     ~ 192.168.255.255    (C 클래스)
```

집이나 회사에서 쓰는 대부분의 기기는 `192.168.x.x` 같은 사설 IP를 가진다.<br>
이들은 공유기(라우터)를 통해 하나의 공인 IP로 인터넷에 접속한다.<br>

### 서브넷 마스크와 서브네팅
IP 주소는 **네트워크 부분**과 **호스트 부분**으로 나뉜다.<br>
서브넷 마스크는 이 경계를 표시하는 값이다.<br>

예를 들어 `192.168.0.1/24`라고 쓰면 `/24`는 앞 24비트가 네트워크 부분이라는 뜻이다.<br>
- 서브넷 마스크는 `255.255.255.0`
- `192.168.0`이 네트워크 주소
- 마지막 `.1`이 호스트 주소

같은 네트워크에 속하려면 네트워크 부분이 같아야 한다.<br>
또, `192.168.0.1/24`일 때 IP로 사용 가능한 범위는 192.168.0.1 ~ 192.168.0.254로 254개이다.<br>
호스트 부분이 모두 0인 `192.168.0.0`은 전체 네트워크에서 작은 네트워크를 식별하는 네트워크 주소<br>
모두 1인 `192.168.0.255`는 브로드캐스트 주소로 예약되어 있기 때문이다.<br>

**서브네팅**

큰 네트워크를 작은 네트워크로 나누는 것을 서브네팅이라고 한다.<br>
회사에서 부서별로 네트워크를 분리하거나, 보안을 위해 네트워크를 격리할 때 사용한다.<br>

`192.168.0.0/24` 네트워크가 있을 때, 호스트 부분에는 0~255가 올 수 있다.<br>
```
원래:
192.168.0.0/24 → 192.168.0.0 ~ 192.168.0.255 (256개 주소)

서브네팅 후:
192.168.0.0/25   → 192.168.0.0   ~ 192.168.0.127  (128개)
192.168.0.128/25 → 192.168.0.128 ~ 192.168.0.255  (128개)
```

`/24`를 `/25`로 바꾸면 네트워크 비트가 1개 늘어나서 서브넷이 2개가 된다.<br>
`/26`이면 4개, `/27`이면 8개로 나뉜다.<br>

서브넷을 나눠서 얻을 수 있는 효과는
- 브로드캐스트 범위가 작아져 네트워크 효율 향상
- 보안 정책을 서브넷 단위로 적용 가능

가 있다.<br>

하지만 서브넷마다 네트워크 주소와 브로드캐스트 주소가 필요해서 사용 가능한 IP가 줄어든다.<br>

### IP 패킷 구조

네트워크 계층에서 데이터 단위를 **패킷(Packet)**이라고 한다.<br>
2계층의 프레임 안에 IP 패킷이 들어가는 구조다.<br>

![image](/assets/img/security/web/PDU.PNG)

4계층에서 온 데이터(TCP 세그먼트 또는 UDP 데이터그램)에 IP 헤더를 붙여서 패킷을 만든다.<br>

**IPv4 패킷 헤더 구조:**

헤더는 최소 20바이트로 구성되며 옵션 포함 시 최대 60바이트이다.<br>

- **버전 (4bit)**: IPv4는 4, IPv6는 6
- **IHL (4bit)**: 헤더 길이
- **TOS (8bit)**: 서비스 유형,패킷의 우선순위와 처리 방식 지정
- **전체 길이 (16bit)**: 헤더+데이터의 전체 크기, 최대 65,535바이트
- **식별자 (16bit)**: 같은 데이터그램의 조각들을 식별하기 위한 ID
- **플래그 (3bit)**: 
  - Reserved (1bit): 예약됨, 항상 0
  - DF (Don't Fragment, 1bit): 1이면 조각화 금지
  - MF (More Fragments, 1bit): 1이면 뒤에 조각이 더 있음
- **조각 오프셋 (13bit)**: 원본 데이터에서 이 조각의 위치. 8바이트 단위
- **TTL (8bit, Time To Live)**: 패킷이 거칠 수 있는 최대 라우터 수. 매 라우터마다 1씩 감소
- **프로토콜 (8bit)**: 상위 계층 프로토콜 (6=TCP, 17=UDP, 1=ICMP)
- **헤더 체크섬 (16bit)**: 헤더 오류 검출용. 데이터는 검사 안 함
- **출발지 IP 주소 (32bit)**
- **목적지 IP 주소 (32bit)**
- **옵션 (가변)**: 선택적 필드. 보안, 라우팅 등
- **패딩**: 옵션이 32비트 배수가 되도록 0으로 채움

의 정보가 담긴다.
### ARP (Address Resolution Protocol)

그런데 우리는 데이터를 보낼 때 보통 IP 주소는 알지만 MAC 주소는 모른다.<br>

2계층에서 프레임을 만들려면 목적지 MAC 주소가 필요한데, IP 주소만으로는 알 수 없다.<br>
이때 사용하는 것이 **ARP** 프로토콜이다. ARP는 **IP 주소를 MAC 주소로 변환**해주는 프로토콜이다.<br>

**ARP 동작 과정:**

1. `192.168.0.5`의 MAC 주소를 알아야 하는 상황.
2. A는 LAN 전체에 **ARP Request**를 브로드캐스트한다
   - 목적지 MAC: `FF:FF:FF:FF:FF:FF` (브로드캐스트)
   - 내용: "IP 주소 `192.168.0.5`를 가졌으면 응답 요구
3. 해당 IP를 가진 컴퓨터 B가 **ARP Reply**로 자신의 MAC 주소를 응답한다
   - 목적지 MAC: A의 MAC 주소 (유니캐스트)
   - 내용: 자신의 MAC 주소 `AA:BB:CC:DD:EE:FF`
4. A는 받은 MAC 주소를 **ARP 캐시**에 저장해두고 사용한다

ARP 캐시는 일정 시간(보통 몇 분) 동안 유지되므로, 매번 ARP 요청을 보낼 필요는 없다.<br>
윈도우에서는 `arp -a` 명령어로 ARP 캐시를 확인할 수 있다.<br>
```bash
$ arp -a
인터페이스: 192.168.0.10
  인터넷 주소          물리적 주소           형식
  192.168.0.1         aa-bb-cc-dd-ee-ff     동적
  192.168.0.5         11-22-33-44-55-66     동적
```

**ARP Spoofing**

**ARP Spoofing** 공격은 거짓 ARP 응답을 보내서 트래픽을 가로챌 수 있다.<br>
```
정상 상황:
컴퓨터 A → 게이트웨이(192.168.0.1) → 인터넷

ARP Spoofing 공격:
공격자가 192.168.0.1의 MAC이 자신의 MAC인 것처럼 거짓 ARP Reply 전송
    ↓
컴퓨터 A의 ARP 캐시가 변조됨
    ↓
컴퓨터 A → 공격자 → 게이트웨이 → 인터넷 (중간자 공격)
```

공격자가 자신이 대답을 해야하는 것처럼 먼저 응답하면 피해자의 모든 인터넷 트래픽이 공격자의 컴퓨터를 거쳐간다.<br>
이를 **중간자 공격(Man-in-the-Middle Attack)**이라 한다.<br>

방어 방법으로는 중요한 기기의 MAC 주소를 수동으로 고정하고, 탐지 도구를 이용할 수 있다.

### ICMP (Internet Control Message Protocol)

**ICMP**는 네트워크 계층에서 오류 보고와 진단에 사용하는 프로토콜이다.<br>
실제 데이터를 전송하는 게 아니라, 네트워크 상태 정보를 주고받는다.<br>

가장 대표적인 ICMP 활용이 **ping** 명령어다.<br>

**ping 동작 원리:**

1. `ping 8.8.8.8` 명령 실행
2. ICMP **Echo Request** 패킷을 `8.8.8.8`로 전송
3. 목적지가 살아있으면 ICMP **Echo Reply** 패킷으로 응답
4. 응답 시간(RTT, Round Trip Time)과 패킷 손실률 표시
```bash
$ ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: icmp_seq=0 ttl=115 time=10.2 ms
64 bytes from 8.8.8.8: icmp_seq=1 ttl=115 time=9.8 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=115 time=11.1 ms

--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 9.8/10.4/11.1/0.5 ms
```

**ICMP 메시지 종류:**

- **Type 0 - Echo Reply**: ping 응답
- **Type 3 - Destination Unreachable**: 목적지에 도달할 수 없음
  - Code 0: 네트워크 도달 불가
  - Code 1: 호스트 도달 불가
  - Code 3: 포트 도달 불가
- **Type 8 - Echo Request**: ping 요청
- **Type 11 - Time Exceeded**: TTL이 0이 되어 패킷 폐기됨
- **Type 5 - Redirect**: 더 나은 경로가 있음을 알림

**traceroute의 원리**

traceroute(윈도우에서는 tracert) 명령은 ICMP를 이용해 경로를 추적한다.<br>
```bash
$ traceroute google.com
 1  192.168.0.1 (192.168.0.1)  1.234 ms
 2  10.1.1.1 (10.1.1.1)  5.678 ms
 3  203.0.113.1 (203.0.113.1)  15.234 ms
 4  142.250.185.46 (142.250.185.46)  20.123 ms
```

동작 원리:
1. TTL=1인 패킷 전송 → 첫 번째 라우터가 "Time Exceeded" 응답
2. TTL=2인 패킷 전송 → 두 번째 라우터가 "Time Exceeded" 응답
3. TTL을 1씩 늘려가며 목적지까지 경로 파악

### 라우터와 라우팅

**라우터**는 서로 다른 네트워크를 연결하고, 패킷을 목적지까지 전달하는 장비다.<br>
스위치가 MAC 주소를 보고 같은 LAN 안에서 전달한다면, 라우터는 IP 주소를 보고 다른 네트워크로 전달한다.<br>

라우터는 내부에 **라우팅 테이블**을 가지고 있다.<br>
이 테이블에는 "어느 네트워크로 가려면 어느 경로로 보내야 하는지" 정보가 저장된다.<br>
```
목적지 네트워크    서브넷 마스크    다음 홉(게이트웨이)  인터페이스
192.168.0.0       255.255.255.0    직접 연결            eth0
10.0.0.0          255.0.0.0        192.168.0.254        eth0
0.0.0.0           0.0.0.0          192.168.0.1          eth0 (기본 경로)
```

**라우팅 동작 과정:**

패킷이 들어오면:
1. 목적지 IP 주소 확인
2. 라우팅 테이블에서 가장 구체적으로 일치하는 항목 찾기
3. 해당 항목의 "다음 홉"으로 패킷 전달
4. 일치하는 항목이 없으면 기본 경로(0.0.0.0/0, Default Gateway)로 전달

예시:
```
목적지 IP: 192.168.0.50
→ 라우팅 테이블 확인
→ 192.168.0.0/24 매칭
→ 직접 연결된 네트워크이므로 ARP로 MAC 주소 찾아서 직접 전달

목적지 IP: 8.8.8.8
→ 라우팅 테이블 확인
→ 매칭되는 항목 없음
→ 기본 경로(0.0.0.0/0) 사용
→ 192.168.0.1(게이트웨이)로 전달
```

이 과정을 **라우팅(Routing)**이라 하며, 패킷이 목적지에 도달할 때까지 여러 라우터를 거치면서 반복된다.<br>

**라우팅 테이블 구성 방법:**

- **정적 라우팅(Static Routing)**: 관리자가 수동으로 경로 설정. 작은 네트워크에 적합.
- **동적 라우팅(Dynamic Routing)**: 라우팅 프로토콜(RIP, OSPF, BGP 등)을 통해 자동으로 경로 학습. 큰 네트워크에 필수.

### 게이트웨이 (Gateway)
라우터에서 다른 네트워크로 들어가는 입구 역할을 하는 곳을 게이트웨이라고 부른다.<br>
LAN에서 WAN으로 나가기 위해 반드시 존재해야 한다.<br>

컴퓨터는 자신이 모르는 목적지로 데이터를 보낼 때, 무조건 기본 게이트웨이로 보낸다.<br>
보통 공유기 설정 페이지 주소로 많이 쓰이는 `192.168.0.1` 같은 주소가 기본 게이트웨이다.<br>

### NAT (Network Address Translation)

앞서 사설 IP는 인터넷에서 직접 접근할 수 없다고 했다.<br>
그럼 사설 IP를 가진 기기는 어떻게 인터넷에 접속할까?

**NAT**는 **사설 IP를 공인 IP로 변환**하는 기술이다.<br>
집이나 회사의 공유기(라우터)가 이 역할을 한다.<br>

#### 내부 → 외부 통신 과정

사설 IP에서 외부 인터넷으로 접속하는 전체 과정을 살펴보자.<br>

**1단계: 내부 네트워크에서 패킷 생성**
```
내부 컴퓨터 (192.168.0.10)가 구글 DNS(8.8.8.8)에 요청

출발지 IP:   192.168.0.10
출발지 포트: 54321 (임시 할당)
목적지 IP:   8.8.8.8
목적지 포트: 53 (DNS)
```

**2단계: 공유기(NAT 라우터) 통과**

공유기가 패킷을 받으면:
```
[변환 전 패킷]
출발지: 192.168.0.10:54321 → 8.8.8.8:53

         ↓ NAT 변환

[변환 후 패킷]
출발지: 203.0.113.5:12345 → 8.8.8.8:53
        (공인 IP)(새 포트)

NAT 테이블 기록:
192.168.0.10:54321 ↔ 203.0.113.5:12345
```

공유기는:
1. 출발지 IP를 자신의 공인 IP(`203.0.113.5`)로 변경
2. 출발지 포트를 새로운 포트(`12345`)로 변경
3. NAT 테이블에 매핑 정보 저장
4. 변환된 패킷을 인터넷으로 전송

**3단계: 외부 서버 응답**
```
구글 DNS 서버가 응답:

출발지: 8.8.8.8:53
목적지: 203.0.113.5:12345 (공유기의 공인 IP와 포트)
```

**4단계: 공유기가 응답 패킷 처리**

공유기가 응답 패킷을 받으면:
```
[받은 패킷]
8.8.8.8:53 → 203.0.113.5:12345

         ↓ NAT 테이블 조회

NAT 테이블: 203.0.113.5:12345 → 192.168.0.10:54321

         ↓ 역변환

[전달할 패킷]
8.8.8.8:53 → 192.168.0.10:54321
```

공유기는:
1. 목적지 포트(`12345`)를 보고 NAT 테이블 확인
2. 원래 내부 주소(`192.168.0.10:54321`) 찾기
3. 목적지 IP와 포트를 원래대로 변환
4. 내부 컴퓨터로 패킷 전달

이렇게 하면 하나의 공인 IP로 수십, 수백 대의 기기가 인터넷을 사용할 수 있다.<br>
이를 **NAPT (Network Address Port Translation)** 또는 **PAT (Port Address Translation)**라고도 한다.<br>

#### 외부 → 내부 접근이 불가능한 이유

하지만 외부에서 내부로 바로 접근하는 것을 불가능하다.<br>

첫번째 이유는 **NAT 테이블에 매핑이 없다**
NAT 테이블은 **내부에서 외부로 연결을 시작할 때만** 생성된다.<br>
```
외부에서 갑자기 패킷이 들어오는 경우:

출발지: 1.2.3.4:80
목적지: 203.0.113.5:12345

공유기의 NAT 테이블 확인...
→ 포트 12345에 대한 매핑이 없음
→ 어느 내부 컴퓨터로 보내야 할지 모르게 됨.
→ 패킷 폐기
```

공유기 입장에서는 "포트 12345로 온 패킷을 어느 내부 기기로 보내야 하는지" 알 수 없다.<br>

두번째 이유는 **사설 IP는 라우팅이 불가능**하다.
사설 IP 주소(`192.168.x.x`, `10.x.x.x` 등)는 인터넷 라우터에서 라우팅되지 않는다.<br>
```
외부 공격자가 192.168.0.10에 직접 접근 시도:

공격자 → 인터넷 라우터 → ... → ❌ (라우팅 불가)

이유: 192.168.0.10은 사설 주소이므로 
인터넷 라우터는 어디로 보내야 할지 모름
```

사설 IP는 로컬 네트워크에서만 유효하고, 인터넷에서는 의미가 없다.<br>

#### 외부에서 내부 서버에 접근하려면?

그렇다면 집에서 웹 서버를 운영하거나 게임 서버를 열고 싶다면 어떻게 해야 할까?<br>

**포트 포워딩 (Port Forwarding)**

공유기 설정에서 특정 포트로 들어오는 요청을 내부 특정 IP로 전달하도록 **미리 설정**한다.<br>
```
포트 포워딩 설정:
외부 포트 80 → 192.168.0.10:8080

설정 후:
외부 요청: 203.0.113.5:80
    ↓
공유기가 자동 변환
    ↓
내부 전달: 192.168.0.10:8080
```

이렇게 하면:
- 외부에서 `203.0.113.5:80`으로 접속
- 공유기가 `192.168.0.10:8080`로 자동 전달
- 내부 웹 서버가 응답

포트 포워딩은 NAT 테이블에 **정적 매핑을 미리 만들어 두는 것**이다.<br>

**DMZ (Demilitarized Zone)**

특정 내부 IP를 완전히 외부에 노출시키는 설정이다.<br>
```
DMZ 설정: 192.168.0.100

모든 외부 요청 → 192.168.0.100으로 전달
```

포트 포워딩과 달리 모든 포트가 열리므로 보안에 매우 취약하다.<br>
테스트 목적이 아니라면 사용하지 않는 것이 좋다.<br>

#### NAT의 장단점

**장점:**
- **IP 주소 절약**: 하나의 공인 IP로 여러 기기 사용 가능
- **보안 효과**: 내부 네트워크 구조 숨김, 외부에서 직접 접근 불가
- **유연성**: 내부 IP 체계를 자유롭게 변경 가능

**단점:**
- **외부 접근 불가**: 포트 포워딩 등 추가 설정 필요
- **P2P 통신 어려움**: 양쪽이 모두 NAT 뒤에 있으면 직접 연결 불가
- **성능 오버헤드**: 패킷마다 주소 변환 필요
- **로그 추적 어려움**: 여러 사용자가 하나의 IP 공유

---

이렇게 3계층에서 데이터가 어떻게 경로를 찾고, 다른 네트워크까지 전달되는지 알아 보았다.<br>
IP 주소로 목적지를 찾고, ARP로 MAC 주소를 알아내고, 라우터가 패킷을 다음 게이트웨이로 전달한다.<br>

다음 글에서는 전송 계층인 4계층을 알아보자.<br>