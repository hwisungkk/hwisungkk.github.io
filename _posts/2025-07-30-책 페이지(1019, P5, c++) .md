---
title: 책 페이지(1019, P5, c++)
date: 2025-07-30 16:33:12 +09:00
last_modified_at: 2025-07-30 17:08:49 +09:00
categories: [algorithm, boj]
tags:
  [
    '수학',
    '구현',
    '백준',                                                                                                                                                      
    '1019'
  ]
---
# **책 페이지**

[책 페이지](https://www.acmicpc.net/problem/1019)

### 문제 
지민이는 전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1 페이지이고, 마지막 페이지는 N 페이지이다.<br>
각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.

### 입력
첫째 줄에 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.

### 출력
첫째 줄에 0이 총 몇 번 나오는지, 1이 총 몇 번 나오는지, ..., 9가 총 몇 번 나오는지를 공백으로 구분해 출력한다.

### 풀이
수학적 특성을 찾아서 풀어야하는 문제인데 우선 각 자리에서 나오는 숫자를 세주기로 했다.<br>
n을 입력받았을 때 일의 자리에서 나오는 숫자의 개수를 따져보면

일의 자리에서
i < n%10 이면 n/10+1개<br>
i == n%10 이어도 n/10+1개<br>
i > n%10 이면 n/10개이다.<br>
0은 일의 자리에서는 그냥 n/10번 나온다.<br>

다음 십의 자리에서 (여기서는 비교 기준이 (n/10)%10 이다)
i < (n/10)%10 이면 n/100\*10 + 10개<br>
i == (n/10)%10 이면 n/100\*10 + (n%10 + 1)개<br>
i > (n/10)%10 이면 n/100*10개이다.<br>

0은 맨 앞자리에 못 오므로 한 블록을 빼서 계산한다.<br>
즉 (n/10)%10 > 0이면 (n/100 - 1)*10 + 10개,<br>
(n/10)%10 == 0이면 (n/100 - 1)*10 + (n%10 + 1)개이다. (n<10이면 0번)

그리고 n자리수일 땐 각 자리 p=1,10,100,…마다 위 규칙을 그대로 쓰면 되고,<br>
0은 그 자리에서 맨 앞자리에 올 수 없는 블록만 자리값(p) 만큼 빼주면 된다.



```c++
#define ll long long
#include <bits/stdc++.h>
using namespace std;
int main()
{
    ios_base ::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    long long mod = 998'244'353;

    bool flag = 0;
    long long a, b, c, d;
    long long n, m, t, k = 0;
    long long ans = 0;

    cin >> n;

    vector<ll> ansv(10, 0);

    a=10;
    ll add=0;

    for(int i=1;n!=0;i*=10) {
        m=n%10;
        n/=10;

        ansv[0]-=i;
        for(int j=0;j<m;j++)ansv[j]+=(n+1)*i;
        ansv[m]+=n*i+1+add;
        for(int j=m+1;j<=9;j++)ansv[j]+=n*i;

        add+=m*i;
    }


    string sp="";

    for(int i=0;i<10;i++){
        cout << sp << ansv[i];
        sp=" ";
    }

    return 0;
}
```