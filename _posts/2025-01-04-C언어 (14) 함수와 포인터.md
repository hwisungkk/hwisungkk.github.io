---
title: C언어 (14) 함수와 포인터
date: 2025-01-04 02:13:42 +09:00
last_modified_at: 2025-01-05 23:00:11 +09:00
categories: [language, C Language]
tags:
  [
    'C언어',
    'C Language',
    'C언어 기초'
  ]
---
# **C언어 (14) 함수와 포인터**
> 여태까지 배운 것을 합쳐서 함수에서 어떻게 포인터를 활용하는지 알아보자.<br>

## call by value vs call by reference
값에 의한 호출(call by value)은 변수의 값을 복사해서 함수를 호출하는 방식이다.<br>
```c
#include <stdio.h>
int func(int n);
int main() {
    int a = 10;
    int result = 0;
    result = func(a);
    printf("%d\n", a);
    printf("%d", result);
    return 0;
}
int func(int n) {
    n += 1;
    return n;
}
```
이 코드의 흐름을 보면, 값이 10인 a로 func(int n) 함수를 호출한다.<br>
int n에는 a의 값인 10이 복사되고, 변수 n은 a와는 다른 메모리 공간을 가지고 10인 값을 가진다.<br>
그 다음 n는 1 증가하고, n의 값이 반환되어 result에 들어간다.<br>
그렇기에 a는 10, result는 11의 값을 가진다. 이렇게 값을 이용해 함수를 호출하는 것이다.<br>

그렇다면 주소에 의한 호출(call by reference)은 어떻게 함수를 호출할까?<br>
포인터를 이용해 주소를 참조해서 함수를 호출한다.<br>

```c
#include <stdio.h>
int func(int* p);
int main() {
    int a = 10;
    int result = 0;
    result = func(&a);
    printf("%d\n", a);
    printf("%d", result);
    return 0;
}
int func(int* p) {
    *p = *p + 1;
    return *p;
}
```
이전과 비슷하게 생긴 코드지만 결과는 11, 11이 출력된다.<br>
흐름을 보면 a의 주소를 통해 func를 호출하고, int\* p에는 a의 주소가 들어간다.<br>
그러면 \*p는 a의 메모리 공간을 의미하고, 거기에 1을 더하니 a에 1을 더한 것과 같다.<br>
이렇게 포인터 변수를 통해 다른 함수에서 지역 변수 a에 저장한 값을 참조하거나 변경할 수 있다.<br>

### 매개 변수로 배열 사용하기
주소를 매개 변수로 함수를 호출할 수 있다는 것은 배열도 매개체가 될 수 있다는 것이다.<br>
int ar[100]같은 큰 데이터를 함수로 보내야 하는데 값을 전부 보내려면 시간과 메모리의 소비가 클 것이다.<br>
하지만 배열의 주소로 함수를 호출하면 쉽고 빠르게 값들을 참조할 수 있다.<br>

```c
#include <stdio.h>
void func(int* p);
int main() {
    int ar[10] = { 1,2,3,4,5,6,7,8,9,10 };
    func(ar);
    return 0;
}
void func(int* p) {
    for (int i = 0; i < 10; i++) {
        printf("%d ", p[i]);
    }
}
```
이렇게 int \*p에 ar배열의 주소를 넣고 반복문을 통해서 배열의 값을 바로 참조할 수 있다.<br>
함수의 인자로는 int\* p가 들어가있는 것을 확인할 수 있다.<br>

마찬가지로 이차원 배열을 매개 변수로 보내려면 어떻게 해야 할까?<br>
배열 포인터를 사용하면 똑같이 할 수 있다.<br>
```c
#include <stdio.h>
void func(int (*p)[4]);
int main() {
    int ar[2][4] = { 
        {1,2,3,4},
        {5,6,7,8}
    };
    func(ar);
    return 0;
}
void func(int(*p)[4]) {
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%d ", p[i][j]);
        }printf("\n");
    }
}
```
포인터를 사용하면 대량의 데이터를 보내야할 때 값을 전부 복사할 필요 없이 주소로만 쉽게 보낼 수 있다!<br>

### 주소를 반환하는 함수
그렇다면 대량의 데이터를 반환해야 한다면 어떻게 해야 할까?<br>
이번에는 반환하는 자료형을 가지는 부분에 포인터형이 들어갈 것이다.<br>
```c
#include <stdio.h>
int* func(void);
int main() {
    int* p;
    p = func();
    for (int i = 0; i < 5; i++) {
        printf("%d ", p[i]);
    }
    return 0;
}
int* func(void) {
    int arr[5] = { 1,2,3,4,5 };
    return arr;
}
```
이렇게 func에서 생성된 배열의 주소를 return해서 main의 \*p로 보낸다.<br>
아무런 문제 없이 배열을 반환한 것처럼 보이고, 결과도 잘 나올 것이다.<br>
하지만 이 코드에는 문제가 있는데 func의 int arr[5]는 func() 지역에 선언된 배열이라는 것이다.<br>
func() 함수가 return하면 지역 변수(배열) arr[5]의 메모리 공간도 같이 소멸된다.<br>
그러면 int \*p에 있는 arr의 주소는 유효하지 않은 메모리를 가리킬 수도 있는 것이다.<br>

이 문제점을 잘 해결할 수 있는 방법을 저번 글에서 봤다. 바로 정적 변수이다.<br>
정적 변수는 함수가 종료된 후에도 메모리 공간이 소멸되지 않기에 위의 문제를 해결할 수 있다.<br>
```c
#include <stdio.h>
int* func(void);
int main() {
    int* p;
    p = func();
    for (int i = 0; i < 5; i++) {
        printf("%d ", p[i]);
    }
    return 0;
}
int* func(void) {
    static int arr[5] = { 1,2,3,4,5 };
    return arr;
}
```
방법도 간단하게 배열 앞에 static을 붙이면 된다. 그러면 안전하게 배열의 주소를 반환할 수 있다.<br>

### main() 함수에 인자가 있을 때


### 함수 포인터

### void형 포인터

---
이제 C언어의 기본 기능은 정말 끝낸 것 같고, 구조체, 문자열, 파일 입출력, 동적 할당 정도가 남았다.<br>
하나씩 잘 알아가보자.