---
title: 9. sort (2)
date: 2025-05-20 03:11:14 +09:00
last_modified_at: 2025-05-20 19:35:22 +09:00
categories: [algorithm, theory]
tags:
  [
    sort,
    정렬,
    알고리즘
  ]
--- 
# **Sort(2)**

알고리즘 문제를 풀 때 사용하는 내장 sort 함수의 시간 복잡도는 O(NlogN)이다.<br>
어떤 것이 있고, 어떻게 응용되어 사용되는지 알아보자.<br>

## O(NlogN)인 정렬

### 병합 정렬
![image](/assets/img/algorithm/sort_merge.gif)<br>

분할 정복을 이용한 정렬 방법으로 원소가 1개 또는 0개 남을 때까지 둘로 쪼갠 다음 쪼갠 순서의 역으로 정렬해 합친다.<br>
분할 정복으로 구현하게 되고, merge(1, n) -> merge(1, n/2) merge(n/2+1, n) .. 처럼 된다.

예시를 보면
```text
[37,26,48,2,19,98,11]
[37,26,48,2] + [19,98,11]
[37,26] + [48,2] / [19,98] + [11]
[37] + [26] / [48] + [2] / [19] + [98] / [11]

로 쪼갠 후
[37] + [26] → [26,37]
[48] + [2] → [2,48]
[19] + [98] → [19,98]

[26,37] + [2,48] → [2,26,37,48]
[19,98] + [11] → [11,19,98]

최종: [2,26,37,48] + [11,19,98] → [2,11,19,26,37,48,98]
의 결과가 나온다.
```
분할 과정을 보면 절반씩 나누기에 NlogN의 시간 복잡도를 가지게 된다.<br>
병합 정렬의 가장 큰 장점은 값이 같은 기존의 데이터의 순서가 지켜지는 stable sort라는 것이 있다.

### heap 정렬
heap 정렬은 적당한 gif가 없어서 생략했다.

heap이라는 이진트리 자료 구조를 이용한 정렬으로 가장 큰 값이나 작은 값을 꺼내며 정렬한다.<br>
루트가 최댓값을 가지는 이진 트리라면 루트를 출력하고 끝 원소와 교환한 후 힙 크기를 줄이고, 루트를 내린다.<br>
그러면 다시 힙 구조가 유지되고 힙의 크기가 1일때까지 반복한다.<br>

heap을 만들 때 O(N), 추출할 때 각각 O(logN)고 N-1번 반복하므로 O(NlogN)의 시간복잡도를 가지는 방법이다.<br>

### quick 정렬
![image](/assets/img/algorithm/sort_quick.gif)<br>

퀵 정렬은 병합 정렬과 비슷하게 나누고 정렬하지만 나누는 기준을 pivot이라는 적절한 원소로 한다.<br>
그 후는 병합 정렬처럼 분할 된 분할 리스트에 대해 또 pivot을 잡고 나누는 과정을 반복한다.<br>
부분 리스트의 크기가 0이나 1일 때 까지 반복하면 정렬이 된 상태가 된다.

이 quick 정렬은 pivot을 선택하는 과정이 정렬 알고리즘의 효율을 결정한다.<br>
만약 계속해서 최솟값이나 최댓값을 pivot으로 선택한다면 O(N^2)의 시간 복잡도를 가지게 된다.<br>
N번의 pivot 선정과 각각 N개의 데이터를 확인해야 하기 때문이다.<br>

그렇기에 pivot을 선택할 때 사용되는 방법은<br>
1. **median of three**<br>
   구간의 처음, 중간, 마지막의 값을 보고 그 중 중앙값을 pivot으로 사용한다.<br>
   우리가 정렬하는 데이터는 어느정도 정렬이 되어있을 때가 많기에 그럴 때 효율적으로 pivot을 잡을 수 있다.

2. **Tukey’s ninther**<br>
   위의 방법을 좀 더 발전시킨 것으로 3개는 표본이 부족해서 좋지 못한 데이터(뒤죽박죽 섞인 상태)에서는 효율적이지<br>
   않은 결과를 낼 수 있다. 그렇기에 왼쪽, 중간, 오른쪽으로 지점을 나눈 후 각각 세 부분에서 median of three를 사용한다.<br>

3. **3-Way partition**<br>
   중복 값이 많은 데이터에서 유리한 방법으로 기본 방법은 중복 값을 신경쓰지 않기에 정렬이 되어 있는 값들을 또 건드린다.<br>
   그렇기에 (< p), (== p), (> p) 3가지의 경우로 나눠서 같은 값의 덩어리를 한번에 축소할 수 있다.<br>

병합, 힙, 퀵 정렬을 표로 보면 아래와 같다.

| 정렬            | 최선           | 평균               | 최악           | 안정성    | 추가메모리         | 실제 체감 속도(일반 배열)           |
| ------------- | ------------ | ---------------- | ------------ | ------ | ------------- | ------------------------- |
| **병합(Merge)** | $O(n\log n)$ | $O(n\log n)$     | $O(n\log n)$ | **안정** | **O(n)** 보조배열 | 보통 2등(큰 데이터에도 꾸준함)        |
| **힙(Heap)**   | $O(n\log n)$ | $O(n\log n)$     | $O(n\log n)$ | 불안정    | O(1) (제자리)    | 셋 중 **가장 느린 편**           |
| **퀵(Quick)**  | $O(n\log n)$ | **$O(n\log n)$** | $O(n^2)$     | 불안정    | O(1) (제자리)    | **보통 1등** (좋은 피벗/3-way 시) |

우선 **병합 정렬**은 두 개의 정렬 구간을 연속으로 접근하기에 캐시 접근에서 유리하다.<br>
하지만 정렬 데이터 크기만큼의 추가 메모리가 필요하고, 작은 구간에서는 오버헤드가 있는 단점이 있다.<br>

**힙 정렬**은 힙이라는 자료구조 특성 상 부모와 자식의 인덱스가 2배씩 차이가 나기에 캐시 접근이 좋지 않다.<br>
또 heap에서 값을 빼고 바꾸면서 비교와 swap 과정이 많기에 오버헤드도 있어 보통 셋 중 가장 느리다.<br>
하지만 어떤 데이터에서도 O(NlogN)이 보장이 된다는 것이 최대 장점이다.<br>

마지막으로 **퀵 정렬**은 같은 배열안에서 부분을 나누므로 캐시 접근이 유리하고 평균적으로 가장 빠르다.<br>
현실 데이터는 기본적으로 어느정도 정렬이 되어있기에 pivot 설정만 잘 하면 가장 좋은 알고리즘이 될 수 있다.<br>

tim, intro, power